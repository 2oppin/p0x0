#!/usr/bin/env node
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 6);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = require("fs");

/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = require("path");

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.p0x0generator = void 0;
const fs = __webpack_require__(0);
const path = __webpack_require__(1);
class p0x0generator {
    constructor(_output = "./", _config = null) {
        this._output = _output;
        this._config = _config;
    }
    static generateRaw(fullName, body) {
        const dir = path.dirname(fullName);
        return new Promise((resolve, reject) => {
            if (!fs.existsSync(dir)) {
                fs.mkdirSync(dir);
            }
            fs.writeFile(fullName, body, null, (err) => {
                return err ? reject(err) : resolve(true);
            });
        });
    }
    get output() {
        return this._output;
    }
    get lang() {
        return this.constructor.name;
    }
    get ext() {
        return this.lang.toLowerCase();
    }
    generate(prototype, output) {
        return p0x0generator.generateRaw((output || this.output) + "/" + prototype.name + "." + this.ext, this.prepare(prototype));
    }
}
exports.p0x0generator = p0x0generator;


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.p0x0convertor = void 0;
const p0x0_1 = __webpack_require__(13);
class p0x0convertor extends p0x0_1.p0x0 {
    get type() {
        return this.constructor.name.toLowerCase();
    }
    constructor() {
        super();
    }
}
exports.p0x0convertor = p0x0convertor;


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.p0x0source = void 0;
class p0x0source {
    constructor(config = null, convertor = null) {
        this.config = config;
        this.convertor = convertor;
    }
}
exports.p0x0source = p0x0source;


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var generator_1 = __webpack_require__(2);
Object.defineProperty(exports, "p0x0generator", { enumerable: true, get: function () { return generator_1.p0x0generator; } });
var ts_1 = __webpack_require__(21);
Object.defineProperty(exports, "ts", { enumerable: true, get: function () { return ts_1.ts; } });
var js_1 = __webpack_require__(22);
Object.defineProperty(exports, "js", { enumerable: true, get: function () { return js_1.js; } });
var sqlite_1 = __webpack_require__(23);
Object.defineProperty(exports, "sqlite", { enumerable: true, get: function () { return sqlite_1.sqlite; } });


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const p0x0gen_1 = __webpack_require__(7);
const p0x0Generator = new p0x0gen_1.p0x0gen(process.argv[2] || "p0x0.json");
p0x0Generator.run();


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.p0x0gen = void 0;
const fs = __webpack_require__(0);
const env_generator_1 = __webpack_require__(8);
const path = __webpack_require__(1);
const p0x0res_1 = __webpack_require__(10);
const config_1 = __webpack_require__(18);
const generators = __webpack_require__(5);
const generator_1 = __webpack_require__(5);
const CARDINALS = ["String", "Int", "Float", "Boolean"];
var LoadableType;
(function (LoadableType) {
    LoadableType["ENTITY"] = "entity";
    LoadableType["IMPLEMENTATION"] = "ID";
    LoadableType["RESOURCE"] = "RES";
})(LoadableType || (LoadableType = {}));
class p0x0gen {
    constructor(configFile) {
        this.configFile = configFile;
        this.generators = [];
        this.sources = [];
    }
    get output() {
        return this.config.output;
    }
    run() {
        return this.loadConfig()
            .then(() => this.prepareEnv())
            .then(() => this.generatePackage(this.config.code, this.baseAppSourcesPath))
            .then(() => true)
            .catch((e) => {
            throw new Error(e);
        });
    }
    generatePackage(pkg, baseDir) {
        const pkgPath = pkg.name ? `${baseDir}/${pkg.name}` : baseDir;
        if (!fs.existsSync(pkgPath)) {
            fs.mkdirSync(pkgPath, { recursive: true });
        }
        return Promise.all([
            ...(pkg.packages || []).map((p) => this.generatePackage(p, pkgPath)),
            ...(pkg.entities || []).map((entityName) => this.load(LoadableType.ENTITY, entityName)
                .then((entity) => this.generateEntityCode(entity, pkgPath))),
        ])
            .then(() => Promise.all([
            ...(pkg.scripts || []).map((script) => generator_1.p0x0generator
                .generateRaw(`${pkgPath}/${script.name}`, script.body)),
        ]));
    }
    generateEntityCode(obj, baseDir) {
        return Promise.all(this.generators.map((g) => g.generate(obj, baseDir)))
            .then((res) => !res.find((r) => r !== true));
    }
    mapCardinals(cardinal) {
        switch (cardinal) {
            case "Int": return Number;
            case "Float": return Number;
            case "Boolean": return Boolean;
            case "String":
            default:
                return String;
        }
    }
    load(type, p0x0Name, ID = null, sources = null) {
        if (type === LoadableType.ENTITY && CARDINALS.includes(p0x0Name)) {
            return Promise.resolve(this.mapCardinals(p0x0Name));
        }
        const _srcStack = (sources || this.sources).slice(0);
        return new Promise((resolve, reject) => {
            const search = () => {
                if (!_srcStack.length) {
                    return Promise.reject(`${p0x0Name} not found in sources: ${(sources || this.sources).map((s) => s.type).join()}`);
                }
                const srcT = _srcStack.pop();
                const typeMap = {};
                typeMap[LoadableType.ENTITY] = () => srcT.load(p0x0Name, false);
                typeMap[LoadableType.IMPLEMENTATION] = () => srcT.loadImplementation(p0x0Name, ID);
                typeMap[LoadableType.RESOURCE] = () => srcT.loadResource(p0x0Name);
                return typeMap[type]()
                    .catch((err) => _srcStack.length
                    ? search()
                    : Promise.reject(err));
            };
            return search()
                .then(resolve)
                .catch((err) => reject(err));
        });
    }
    async loadObject(obj, entity) {
        for (const prop in obj) {
            if (typeof obj[prop] === "object") {
                if (!entity.fields[prop]) {
                    throw new Error(`Unknown property "${prop}" in ${entity.name}`);
                }
                const [type, isArray, isMap, isFunction] = this.getTypeFromString(entity.fields[prop]);
                const propEnt = (await this.load(LoadableType.ENTITY, type));
                const getPropValFnc = async (val) => {
                    if (val.RES)
                        return await this.load(LoadableType.RESOURCE, val.RES);
                    if (val.ID) {
                        val = await this.load(LoadableType.IMPLEMENTATION, propEnt.name, val.ID)
                            .then((imp) => ({ ...imp, ...val }));
                    }
                    return await this.loadObject(val, propEnt);
                };
                if (isArray) {
                    obj[prop] = await Promise.all(obj[prop].map((v) => getPropValFnc(v)));
                }
                else {
                    obj[prop] = await getPropValFnc(obj[prop]);
                }
            }
        }
        return obj;
    }
    async loadInstance(instName, data) {
        const instanceEntity = await this.load(LoadableType.ENTITY, instName);
        return (data.ID
            ? this.load(LoadableType.IMPLEMENTATION, instName, data.ID)
            : Promise.resolve(data))
            .then(async (reqImp) => ({
            ...(await this.loadObject(reqImp, instanceEntity)),
            ...data,
        }));
    }
    getTypeFromString(propValue) {
        const [isMap, , type, isArray, isFunction] = propValue.match(/(Map<[A-Za-z][A-Za-z\d]*,\s*)*([A-Za-z][A-Za-z\d]*)>?(\[\])*(\([^)]*\))*/);
        return [type, !!isArray, !!isMap, !!isFunction];
    }
    async prepareEnv() {
        if (!this.config.env)
            return null;
        const envGen = new env_generator_1.EnvGenerator(this.config.env, `${path.dirname(this.configFile)}/${this.config.output}`);
        return await envGen.run();
    }
    loadConfig() {
        return new Promise((resolve, reject) => fs.readFile(this.configFile, (err, data) => {
            if (err)
                return reject(err);
            return resolve(new config_1.p0x0genConfig(JSON.parse(data.toString())));
        }))
            .then(async (conf) => {
            this.config = conf;
            if (!this.config.validate()) {
                this.config = null;
                throw new Error("Invalid config.");
            }
            this.baseAppSourcesPath = `${path.dirname(this.configFile)}/${this.config.output}`;
            this.generators = this.config.generators.map((src) => {
                let cnf = null, lang;
                if (typeof src === "string") {
                    lang = src;
                }
                else {
                    lang = src.lang;
                    cnf = src;
                }
                if (!generators[lang])
                    throw new Error(`Invalid config: unknown generator ${lang}.`);
                return (new generators[lang](this.baseAppSourcesPath
                    + (this.config.code && this.config.code.name ? `/${this.config.code.name}` : ""), cnf || { lang }));
            });
            for (const src of this.config.sources) {
                this.sources.push(p0x0res_1.sourceFactory(src));
            }
            if (this.config.env) {
                this.config.env = await this.loadInstance("Environment", this.config.env);
            }
            if (this.config.code) {
                this.config.code = await this.loadInstance("Package", this.config.code);
            }
            return this.config;
        });
    }
}
exports.p0x0gen = p0x0gen;


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.EnvGenerator = void 0;
const fs = __webpack_require__(0);
const path = __webpack_require__(1);
const dockerCompose_1 = __webpack_require__(9);
class EnvGenerator {
    constructor(env, output) {
        this.env = env;
        this.output = output;
        this.env.name = `${this.output}/${this.env.name}`;
        this.output = path.dirname(this.env.name);
    }
    async run() {
        // Prepare docker-compose.yaml out of Environment entity
        await fs.promises.mkdir(this.output, { recursive: true })
            .then(() => fs.promises.writeFile(this.env.name, (new dockerCompose_1.dockerCompose()).prepare(this.env, this.output)));
        await Promise.all(this.env.containers.map((c) => this.prepareContainerFiles(c)));
    }
    async prepareContainerFiles(container) {
        if (container.image)
            return Promise.resolve();
        if (!container.dockerfile || !container.dockerfile.name)
            throw new Error("Container has nor image nor custom Dockerfile");
        const dir = `${this.output}/${container.name}`;
        await fs.promises.mkdir(`${dir}`, { recursive: true });
        (container.scripts || []).forEach(async (script) => await fs.promises.mkdir(path.dirname(`${dir}/${script.name}`), { recursive: true }));
        return Promise.all([
            fs.promises.writeFile(`${dir}/${container.dockerfile.name}`, container.dockerfile.body),
            ...(container.scripts || []).map((script) => fs.promises.writeFile(`${dir}/${script.name}`, script.body)),
        ]);
    }
}
exports.EnvGenerator = EnvGenerator;


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.dockerCompose = void 0;
const path = __webpack_require__(1);
class dockerCompose {
    prepare(env, output) {
        return `\
version: '3'
  services:
${env.containers.map(this.prepareContainer(output))}`;
    }
    prepareContainer(output) {
        return (container) => {
            return container.image
                ?
                    `    image: ${container.image}\n`
                :
                    `    build:
        context: ./${path.relative(output, `${output}/${container.name}/${container.dockerfile.name}`)}` +
                        `\n    tty: true
    volumes:\n` +
                        Object.entries(container.volumes).map(([src, dst]) => `        - ${src}:${dst}`).join("\n")
                        + `${container.scripts && container.scripts.length ?
                            `\n    command: bash -c "${container.scripts.map((s) => s.interpreterString).join(" && ")}"` : ""}`
                        + (container.links
                            ?
                                `\n    links:\n
      -${container.links.join("\n      -")}`
                            : "")
                        + "\n";
        };
    }
}
exports.dockerCompose = dockerCompose;


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.sourceFactory = exports.formatTypes = void 0;
const formats_1 = __webpack_require__(11);
const file_source_1 = __webpack_require__(15);
const remote_source_1 = __webpack_require__(16);
const _formatTypes = {};
for (const srct of formats_1.formats) {
    _formatTypes[(new srct()).type] = srct;
}
exports.formatTypes = _formatTypes;
function sourceFactory(conf) {
    let source = file_source_1.p0x0fileSource;
    const cnf = typeof conf === "string"
        ? { type: conf }
        : conf;
    if (cnf.url) {
        source = remote_source_1.p0x0remoteSource;
    }
    return new source(cnf, new exports.formatTypes[cnf.type](cnf));
}
exports.sourceFactory = sourceFactory;


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.formats = void 0;
const json_1 = __webpack_require__(12);
const p0x0_1 = __webpack_require__(14);
exports.formats = [json_1.json, p0x0_1.p0x0];


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.json = void 0;
const convertor_1 = __webpack_require__(3);
class json extends convertor_1.p0x0convertor {
    convert(buff) {
        return Promise.resolve(JSON.parse(buff.toString()));
    }
}
exports.json = json;


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.p0x0 = void 0;
class p0x0 {
}
exports.p0x0 = p0x0;


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.p0x0 = void 0;
const convertor_1 = __webpack_require__(3);
class p0x0 extends convertor_1.p0x0convertor {
    convert(buff) {
        return Promise.resolve(JSON.parse(buff.toString()));
    }
}
exports.p0x0 = p0x0;


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.p0x0fileSource = void 0;
const fs = __webpack_require__(0);
const source_1 = __webpack_require__(4);
class p0x0fileSource extends source_1.p0x0source {
    constructor(config = null, convertor = null) {
        super(config, convertor);
        this.config = config;
        this.convertor = convertor;
        this._dir = `${process.cwd()}/entities`;
        if (this.config && this.config.dir) {
            if (!this._dir.match(/^\//)) {
                const relPath = this._dir.match(/^\.\//)
                    ? this.config.dir.slice(2)
                    : this.config.dir;
                this._dir = `${process.cwd()}/${relPath}`;
            }
            else {
                this._dir = this.config.dir;
            }
        }
    }
    get type() { return this.convertor.type; }
    get dir() { return this._dir; }
    get ext() {
        return this.convertor.type;
    }
    loadImplementation(name, ID) {
        const p0x0FileName = `${ID}.${this.ext}`;
        return this.readFile(p0x0FileName)
            .then((buff) => this.convertor.convert(buff));
    }
    loadResource(RESID) {
        return this.readFile(RESID);
    }
    load(name, raw = false) {
        const p0x0FileName = `${name}.${this.ext}`;
        return this.readFile(p0x0FileName)
            .then(async (buff) => raw
            ? buff.toString()
            : await this.convertor.convert(buff));
    }
    readFile(p0x0FileName) {
        return new Promise((resolve, reject) => fs.readFile(this._dir + "/" + p0x0FileName, (err, res) => {
            if (err)
                return reject(err);
            resolve(res);
        }));
    }
}
exports.p0x0fileSource = p0x0fileSource;


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.p0x0remoteSource = void 0;
const http = __webpack_require__(17);
const source_1 = __webpack_require__(4);
class p0x0remoteSource extends source_1.p0x0source {
    constructor(config, convertor = null) {
        super(config, convertor);
        this.config = config;
        this.convertor = convertor;
    }
    get type() { return this.convertor.type; }
    get dir() { return this._dir; }
    get ext() {
        return this.convertor.type;
    }
    loadImplementation(name, ID) {
        return this.getRemote(`${this.config.url}/${name}/${ID}`)
            .then((buff) => this.convertor.convert(buff));
    }
    loadResource(RES) {
        return this.getRemote(`${this.config.url}/${RES}`);
    }
    load(name, raw = false) {
        return this.getRemote(`${this.config.url}/${name}`)
            .then(async (buff) => raw
            ? buff.toString()
            : await this.convertor.convert(buff));
    }
    getRemote(url) {
        return new Promise((resolve, reject) => http.get(url, (res) => {
            if (res.statusCode < 200 || res.statusCode >= 400)
                reject(res.statusCode);
            let body = "";
            res.on("data", (data) => body += data);
            res.on("end", () => resolve(new Buffer(body)));
        }));
    }
}
exports.p0x0remoteSource = p0x0remoteSource;


/***/ }),
/* 17 */
/***/ (function(module, exports) {

module.exports = require("http");

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.p0x0genConfig = void 0;
const model_1 = __webpack_require__(19);
class p0x0genConfig extends model_1.Model {
    constructor(config) {
        super({
            generators: ["ts"],
            output: "generator/",
            sources: [{ type: "json" }],
            ...config,
        });
    }
    validate() {
        const rules = [
            () => this.output.search(/\.\.\//) === -1,
        ];
        for (const r of rules) {
            if (!r()) {
                return false;
            }
        }
        return true;
    }
}
exports.p0x0genConfig = p0x0genConfig;


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Model = void 0;
const utils_1 = __webpack_require__(20);
class Model {
    constructor(data = {}) {
        this.populate(data);
    }
    populate(data) {
        for (let i = 0, a = Object.getOwnPropertyNames(data); i < a.length; i++) {
            if (typeof data[a[i]] === "function") {
                this[a[i]] = data[a[i]].bind(this);
            }
            else {
                this[a[i]] = utils_1.Utils.deepCopy(data[a[i]]);
            }
        }
        return this;
    }
    get list() {
        const res = {};
        for (const p of Object.getOwnPropertyNames(this)) {
            res[p] = this[p];
        }
        return res;
    }
}
exports.Model = Model;


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Utils = void 0;
class Utils {
    static deepCopy(obj) {
        let copy;
        // Handle the 3 simple types, and null or undefined
        if (null == obj || "object" !== typeof obj)
            return obj;
        // Handle Date
        if (obj instanceof Date) {
            copy = new Date();
            copy.setTime(obj.getTime());
            return copy;
        }
        // Handle Array
        if (obj instanceof Array) {
            copy = [];
            for (let i = 0, len = obj.length; i < len; i++) {
                copy[i] = Utils.deepCopy(obj[i]);
            }
            return copy;
        }
        // Handle Object
        if (obj instanceof Object) {
            copy = {};
            for (const attr in obj) {
                if (obj.hasOwnProperty(attr))
                    copy[attr] = Utils.deepCopy(obj[attr]);
            }
            return copy;
        }
        throw new Error("Unable to copy obj! Its type isn't supported.");
    }
}
exports.Utils = Utils;
Utils.randomColor = (base = 0) => "rgb(" + ["", "", ""].map(() => base + Math.round(Math.random() * (255 - base))).join() + ")";
Utils.capitaize = (s) => s[0].toUpperCase() + s.slice(1);
Utils.e = (_enum, val) => Number.isNaN(+val) ? _enum[_enum[val]] : _enum[val];
Utils.el = (_enum) => Object.getOwnPropertyNames(_enum).filter((v) => Number.isNaN(+v));
Utils.en = (_enum, val) => Number.isNaN(+val) ? _enum[val] : _enum[_enum[val]];
Utils.enl = (_enum) => Object.getOwnPropertyNames(_enum).map((v) => _enum[v]).filter((v) => !Number.isNaN(+v));
Utils.floor = (val, prc) => (Math.floor(val * (10 ** prc)) / (10 ** prc));
Utils.sum = (_arr) => _arr.length ? _arr.slice(0).reduce((a, b) => a + b, 0) : 0;
Utils.sumo = (_arr, prop) => Utils.sum(_arr.map((a) => a[prop]));
Utils.avg = (_arr) => _arr.length ? Utils.sum(_arr) / _arr.length : 0;
Utils.avgo = (_arr, prop) => _arr.length ? Utils.sumo(_arr, prop) / _arr.length : 0;
Utils.bigX = (_arr, x) => _arr.slice(0).sort((a, b) => b - a).slice(0, x);
Utils.big3 = (_arr) => Utils.bigX(_arr, 3);
Utils.big3o = (_arr, prop) => _arr.slice(0).sort((a, b) => b[prop] - a[prop]).slice(0, 3);
// @ts-ignore
Utils.dstr = (n) => [...new Array(n)]
    .reduce((a, _, i) => a[1].push(-a[0] + (a[0] += (1 - a[0]) * (n - i < 2 ? 1 : Math.random()))) && a, [0, []])[1];
Utils.diffMonths = (d1, d2) => d2.getFullYear() * 12 + d2.getMonth() - d1.getFullYear() * 12 - d1.getMonth();


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ts = void 0;
const generator_1 = __webpack_require__(2);
class ts extends generator_1.p0x0generator {
    constructor(_output = "./", _config = { lang: "ts" }) {
        super();
        this._output = _output;
        this._config = _config;
    }
    prepare(obj) {
        let imports = this._config.imports ? `import { ${this._config.imports.join(", ")} } from "./imports";\n\n` : "";
        const allowedTypes = (this._config.imports || []).concat(...["number", "string", "Date"]), base = (obj.base && obj.base.name) || this._config.baseClass || null, using = (obj.using || []).concat(...(base && !allowedTypes.includes(base) && [base]) || []), extend = base ? `extends ${base} ` : "";
        if (using.length) {
            imports += using.map((u) => `import { ${u} } from "./${u}";`).join("\n") + "\n";
            allowedTypes.concat(...using);
        }
        const fields = obj.fields, fieldsNames = Object.getOwnPropertyNames(fields);
        let res = `${imports}/**
 * Class ${obj.name}
 */
export class ${obj.name} ${extend}{
`;
        for (const p of fieldsNames) {
            const v = JSON.stringify((fields[p] && fields[p].default) || null);
            let t = fields[p].type || obj.fields[p];
            if (!t || !allowedTypes.includes(t.replace(/[\[\]]]/, "")))
                t = "any";
            res += `    public ${p}: ${t} = ${v};\n`;
        }
        res += `}\n`;
        return res;
    }
}
exports.ts = ts;


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.js = void 0;
const generator_1 = __webpack_require__(2);
class js extends generator_1.p0x0generator {
    constructor(_output = "./", _config = { lang: "ts" }) {
        super();
        this._output = _output;
        this._config = _config;
    }
    prepare(obj) {
        let imports = this._config.imports
            ? `var GImports_1 = require("./imports)");\n`
                + this._config.imports.map((u) => `var ${u}_1 = GImports_1.${u};`).join("\n")
                + "\n"
            : "";
        const using = (obj.using || []), base = (obj.base && obj.base.name) || this._config.baseClass || null, extend = base ? `${base}_1.${base}` : "";
        if (using.length) {
            imports += using.map((u) => `var ${u}_1 = require("./${u}");`).join("\n") + "\n";
        }
        const fields = obj.fields, fieldsNames = Object.getOwnPropertyNames(fields);
        let res = `
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
`
            +
                imports
            +
                `
/**
 * Class ${obj.name}
 */
var ${obj.name} = /** @class */ (function (_super) {
    __extends(${obj.name}, _super);
    function ${obj.name}() {
        var _this = _super !== null && _super.apply(this, arguments) || this;`;
        for (const p of fieldsNames) {
            const v = JSON.stringify((fields[p] && fields[p].default) || null);
            res += `        _this.${p} = ${v};\n`;
        }
        res += `
        return _this;
    }
    return ${obj.name};
}(${extend}));
exports.${obj.name} = ${obj.name};
`;
        return res;
    }
}
exports.js = js;


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.sqlite = void 0;
const generator_1 = __webpack_require__(2);
class sqlite extends generator_1.p0x0generator {
    prepare(obj) {
        let res = `CREATE TABLE "${obj.name}" (`, names = Object.getOwnPropertyNames(obj.fields);
        const fields = obj.fields;
        const columns = [];
        for (let base = obj.base; base && base.fields; base = base.base) {
            const baseFields = base.fields;
            names = names.concat(Object.getOwnPropertyNames(baseFields));
        }
        for (const p of names) {
            const d = (fields[p] && fields[p].default) || "NULL", v = JSON.stringify(obj[p] || "") && ` DEFAULT ${d}`, t = (fields[p] && fields[p].default) && !isNaN(d) ? (d.toString().indexOf(".") !== -1 ? "INTEGER" : "REAL") : "TEXT";
            columns.push(`\t"${p}" ${t} ${v}`);
        }
        res += columns.join(",\n") + `);`;
        return res;
    }
}
exports.sqlite = sqlite;


/***/ })
/******/ ]);