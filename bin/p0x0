#!/usr/bin/env node
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 11);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.p0x0generator = void 0;
const fs = __webpack_require__(1);
const platform_1 = __webpack_require__(6);
const path = __webpack_require__(4);
class p0x0generator {
    constructor(_output = "./", _config = null, sources) {
        this._output = _output;
        this._config = _config;
        this.sources = sources;
    }
    static generateRaw(fullName, body) {
        const dir = path.dirname(fullName);
        return new Promise((resolve, reject) => {
            if (!fs.existsSync(dir)) {
                fs.mkdirSync(dir);
            }
            fs.writeFile(fullName, body, null, (err) => {
                return err ? reject(err) : resolve(true);
            });
        });
    }
    get output() {
        return this._output;
    }
    get platform() {
        return new platform_1.Platform({
            name: this.constructor.name,
        });
    }
    get ext() {
        return this.platform.name.toLowerCase();
    }
    async generate(prototype, output) {
        return p0x0generator.generateRaw((output || this.output) + "/" + prototype.name + "." + this.ext, Buffer.from(await this.prepare(prototype)));
    }
}
exports.p0x0generator = p0x0generator;


/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = require("fs");

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Entity = exports.CARDINALS = void 0;
const model_1 = __webpack_require__(3);
exports.CARDINALS = ["None", "String", "Int", "Float", "Bool"];
const MAP_TYPE_REG = /^(\?)?(\*)?(\+)?(@)?Map<\s*([A-Za-z][A-Za-z\d]+)\s*,\s*([A-Za-z][A-Za-z\d]+)(\[\d*\])*(\([^)]*\))*\s*>(=(.|[\r\n]))*$/;
const OTHER_TYPE_REG = /^(\?)?(\*)?(\+)?(@)?([A-Za-z][A-Za-z\d]*)(\[\d*\])*(\([^)]*\))*(=((.|[\r\n])+))*$/;
class Entity extends model_1.Model {
    constructor(data = {}) {
        super({ name: "", base: null, dependencies: [], ...data });
    }
    static getTypeFromString(propValue) {
        let arraySize = false, functionArguments = false, dfault;
        let nullable, isPrivate, isProtected, isStatic, mapKey, type;
        const isMapMatches = propValue.match(MAP_TYPE_REG);
        if (isMapMatches) {
            [, nullable, isPrivate, isProtected, isStatic, mapKey, type, arraySize, functionArguments, , , dfault] = isMapMatches;
        }
        else {
            [, nullable, isPrivate, isProtected, isStatic, type, arraySize, functionArguments, , dfault] =
                propValue.match(OTHER_TYPE_REG);
        }
        arraySize = arraySize && ((+arraySize.substr(1, arraySize.length - 2)) || -1);
        functionArguments = functionArguments ? functionArguments.replace(/[()]/g, "").split(",") : null;
        mapKey = isMapMatches ? mapKey : null;
        return { type, arraySize, mapKey, functionArguments, isPrivate, isProtected, isStatic, nullable,
            default: dfault,
        };
    }
}
exports.Entity = Entity;


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Model = void 0;
const utils_1 = __webpack_require__(5);
class Model {
    constructor(data = {}) {
        this.populate(data);
    }
    populate(data) {
        for (let i = 0, a = Object.getOwnPropertyNames(data); i < a.length; i++) {
            if (typeof data[a[i]] === "function") {
                this[a[i]] = data[a[i]].bind(this);
            }
            else {
                this[a[i]] = utils_1.Utils.deepCopy(data[a[i]]);
            }
        }
        return this;
    }
    get list() {
        const res = {};
        for (const p of Object.getOwnPropertyNames(this)) {
            res[p] = this[p];
        }
        return res;
    }
}
exports.Model = Model;


/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = require("path");

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Utils = void 0;
class Utils {
    static merge(obj, obj2) {
        if (typeof obj2 !== "object" || !obj)
            return obj2;
        Object.entries(obj2).forEach(([key, value]) => {
            obj[key] = Utils.merge(obj[key], value);
        });
        return obj;
    }
    static deepCopy(obj) {
        let copy;
        // Handle the 3 simple types, and null or undefined
        if (null == obj || "object" !== typeof obj)
            return obj;
        // Handle Date
        if (obj instanceof Date) {
            copy = new Date();
            copy.setTime(obj.getTime());
            return copy;
        }
        // Handle Array
        if (obj instanceof Array) {
            copy = [];
            for (let i = 0, len = obj.length; i < len; i++) {
                copy[i] = Utils.deepCopy(obj[i]);
            }
            return copy;
        }
        // Handle Object
        if (obj instanceof Object) {
            copy = {};
            for (const attr in obj) {
                if (obj.hasOwnProperty(attr))
                    copy[attr] = Utils.deepCopy(obj[attr]);
            }
            return copy;
        }
        throw new Error("Unable to copy obj! Its type isn't supported.");
    }
}
exports.Utils = Utils;
Utils.randomColor = (base = 0) => "rgb(" + ["", "", ""].map(() => base + Math.round(Math.random() * (255 - base))).join() + ")";
Utils.capitaize = (s) => s[0].toUpperCase() + s.slice(1);
Utils.e = (_enum, val) => Number.isNaN(+val) ? _enum[_enum[val]] : _enum[val];
Utils.el = (_enum) => Object.getOwnPropertyNames(_enum).filter((v) => Number.isNaN(+v));
Utils.en = (_enum, val) => Number.isNaN(+val) ? _enum[val] : _enum[_enum[val]];
Utils.enl = (_enum) => Object.getOwnPropertyNames(_enum).map((v) => _enum[v]).filter((v) => !Number.isNaN(+v));
Utils.floor = (val, prc) => (Math.floor(val * (10 ** prc)) / (10 ** prc));
Utils.sum = (_arr) => _arr.length ? _arr.slice(0).reduce((a, b) => a + b, 0) : 0;
Utils.sumo = (_arr, prop) => Utils.sum(_arr.map((a) => a[prop]));
Utils.avg = (_arr) => _arr.length ? Utils.sum(_arr) / _arr.length : 0;
Utils.avgo = (_arr, prop) => _arr.length ? Utils.sumo(_arr, prop) / _arr.length : 0;
Utils.bigX = (_arr, x) => _arr.slice(0).sort((a, b) => b - a).slice(0, x);
Utils.big3 = (_arr) => Utils.bigX(_arr, 3);
Utils.big3o = (_arr, prop) => _arr.slice(0).sort((a, b) => b[prop] - a[prop]).slice(0, 3);
// @ts-ignore
Utils.dstr = (n) => [...new Array(n)]
    .reduce((a, _, i) => a[1].push(-a[0] + (a[0] += (1 - a[0]) * (n - i < 2 ? 1 : Math.random()))) && a, [0, []])[1];
Utils.diffMonths = (d1, d2) => d2.getFullYear() * 12 + d2.getMonth() - d1.getFullYear() * 12 - d1.getMonth();


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Platform = void 0;
const model_1 = __webpack_require__(3);
class Platform extends model_1.Model {
}
exports.Platform = Platform;


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Resource = void 0;
class Resource {
    constructor({ name, body }) {
        this.name = name;
        this.body = Buffer.from(body);
    }
}
exports.Resource = Resource;


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Script = void 0;
const platform_1 = __webpack_require__(6);
const resource_1 = __webpack_require__(7);
class Script extends resource_1.Resource {
    constructor(data) {
        super(data);
        if (data.platform) {
            this.platform = new platform_1.Platform(data.platform);
        }
    }
    get interpreterString() {
        if (!this.platform.interpreter)
            throw new Error(`Not interpretational language/platform ${this.platform.name}`);
        return [
            this.platform.interpreter,
            Object.entries(this.params || {}).map((k, v) => `${k ? `-${k}` : ""} ${v}`).join(" "),
            this.name,
        ].join(" ");
    }
    get compileString() {
        if (!this.platform.compiler)
            throw new Error(`Not compiling language/platform ${this.platform.name}`);
        return [
            this.platform.compiler,
            Object.entries(this.params || {}).map((k, v) => `${k ? `-${k}` : ""} ${v}`).join(" "),
            this.name,
        ].join(" ");
    }
}
exports.Script = Script;


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.p0x0convertor = void 0;
const p0x0_1 = __webpack_require__(22);
class p0x0convertor extends p0x0_1.p0x0 {
    get type() {
        return this.constructor.name.toLowerCase();
    }
    constructor() {
        super();
    }
}
exports.p0x0convertor = p0x0convertor;


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.p0x0source = void 0;
class p0x0source {
    constructor(config = null, convertor = null) {
        this.config = config;
        this.convertor = convertor;
    }
}
exports.p0x0source = p0x0source;


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const p0x0gen_1 = __webpack_require__(12);
const p0x0Generator = new p0x0gen_1.p0x0gen(process.argv[2] || "p0x0.json");
p0x0Generator.run();


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.p0x0gen = void 0;
const fs = __webpack_require__(1);
const package_1 = __webpack_require__(13);
const platform_1 = __webpack_require__(6);
const env_generator_1 = __webpack_require__(14);
const sourcePool_1 = __webpack_require__(18);
const path = __webpack_require__(4);
const p0x0res_1 = __webpack_require__(19);
const utils_1 = __webpack_require__(5);
const config_1 = __webpack_require__(27);
const generators = __webpack_require__(28);
class p0x0gen {
    // protected sources: p0x0source[] = [];
    constructor(configFile) {
        this.configFile = configFile;
        this.generators = [];
    }
    get output() {
        return this.config.output;
    }
    run() {
        return this.loadConfig()
            .then(() => this.prepareEnv())
            .then(() => this.config.code.generate(this.baseAppSourcesPath, this.generators))
            .then(() => true);
    }
    async prepareEnv() {
        if (!this.config.env)
            return null;
        const envGen = new env_generator_1.EnvGenerator(this.config.env, `${path.dirname(this.configFile)}/${this.config.output}`);
        return await envGen.run();
    }
    loadConfig() {
        return new Promise((resolve, reject) => fs.readFile(this.configFile, (err, data) => {
            if (err)
                return reject(err);
            return resolve(new config_1.p0x0genConfig(JSON.parse(data.toString())));
        }))
            .then(async (conf) => {
            this.config = conf;
            if (!this.config.validate()) {
                this.config = null;
                throw new Error("Invalid config.");
            }
            this.baseAppSourcesPath = `${path.dirname(this.configFile)}/${this.config.output}`;
            const sources = [];
            for (const src of this.config.sources) {
                sources.push(p0x0res_1.sourceFactory(src));
            }
            this.sourcePool = new sourcePool_1.SourcePool(sources);
            this.generators = this.config.generators.map((src) => this.addGenerator(src, this.sourcePool));
            if (this.config.env) {
                this.config.env = await this.sourcePool.loadInstance("Environment", this.config.env);
            }
            if (this.config.code) {
                // Allow have strings instead of object
                this.config.code = await this.preparePackageEntities(this.config.code);
                this.config.code = new package_1.Package(await this.sourcePool.loadInstance("Package", this.config.code));
            }
            return this.config;
        });
    }
    async preparePackageEntities(pkg) {
        // Allow have strings instead of object
        pkg.entities = await Promise.all((pkg.entities || []).map(async (ent) => {
            let entModel;
            if (typeof ent === "string") {
                entModel = await this.sourcePool.loadEntity(ent);
            }
            else {
                entModel = utils_1.Utils.merge(await this.sourcePool.loadEntity(ent.name), ent);
            }
            if (entModel.platforms) {
                entModel.platforms = (entModel.platforms || []).map((p) => typeof p === "string" ? new platform_1.Platform({ name: p }) : p);
            }
            return entModel;
        }));
        pkg.packages = await Promise.all((pkg.packages || []).map((subPkg) => {
            return this.preparePackageEntities(subPkg);
        }));
        return pkg;
    }
    addGenerator(gen, sources) {
        let cnf = null, lang;
        if (typeof gen === "string") {
            lang = gen;
        }
        else {
            lang = gen.platform;
            cnf = gen;
        }
        if (!generators[lang])
            throw new Error(`Invalid config: unknown generator ${lang}.`);
        return (new generators[lang](this.baseAppSourcesPath
            + (this.config.code && this.config.code.name ? `/${this.config.code.name}` : ""), cnf || { lang }, sources));
    }
}
exports.p0x0gen = p0x0gen;


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Package = void 0;
const fs = __webpack_require__(1);
const entity_1 = __webpack_require__(2);
const model_1 = __webpack_require__(3);
const resource_1 = __webpack_require__(7);
const script_1 = __webpack_require__(8);
const generator_1 = __webpack_require__(0);
class Package extends model_1.Model {
    constructor(data) {
        const { parent, name } = data;
        super({ parent, name });
        this.packages = (data.packages || []).map((p) => new Package({ ...p, parent: { name: this.name, parent: this.parent } }));
        this.entities = (data.entities || []).map((e) => new entity_1.Entity({ ...e, package: this.fullName }));
        this.scripts = (data.scripts || []).map((s) => new script_1.Script(s));
        this.resources = (data.resources || []).map((r) => new resource_1.Resource(r));
    }
    get fullName() {
        let parent = this.parent;
        let fullName = this.name;
        while (parent) {
            fullName = `${parent.name}/${fullName}`;
            parent = parent.parent;
        }
        return fullName;
    }
    generate(baseDir, generators) {
        const pkgPath = this.name ? `${baseDir}/${this.name}` : baseDir;
        if (!fs.existsSync(pkgPath)) {
            fs.mkdirSync(pkgPath, { recursive: true });
        }
        return Promise.all([
            ...(this.packages || []).map((p) => p.generate(pkgPath, generators)),
            ...(this.entities || []).map((entity) => Promise.all(generators
                .filter((gen) => !entity.platforms || entity.platforms.find((pl) => gen.platform.name === pl.name))
                .map((gen) => gen.generate(entity, pkgPath)))),
        ])
            .then(() => Promise.all([
            ...(this.scripts || []).map((script) => generator_1.p0x0generator
                .generateRaw(`${pkgPath}/${script.name}`, Buffer.from(script.body))),
        ]))
            .then(() => Promise.all([
            ...(this.resources || []).map((res) => {
                const body = res.body;
                const data = Buffer.from(res.body);
                return generator_1.p0x0generator
                    .generateRaw(`${pkgPath}/${res.name}`, data);
            }),
        ]));
    }
}
exports.Package = Package;


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.EnvGenerator = void 0;
const fs = __webpack_require__(1);
const path = __webpack_require__(4);
const environment_1 = __webpack_require__(15);
const dockerCompose_1 = __webpack_require__(17);
class EnvGenerator {
    constructor(env, output) {
        this.env = env;
        this.output = output;
        this.env = new environment_1.Environment(this.env);
        this.env.name = `${this.output}/${this.env.name}`;
        this.output = path.dirname(this.env.name);
    }
    async run() {
        // Prepare docker-compose.yaml out of Environment entity
        await fs.promises.mkdir(this.output, { recursive: true })
            .then(() => fs.promises.writeFile(this.env.name, (new dockerCompose_1.dockerCompose()).prepare(this.env, this.output)));
        this.env.containers = await Promise.all(this.env.containers.map((c) => this.prepareContainerFiles(c)));
    }
    async prepareContainerFiles(container) {
        if (container.image)
            return Promise.resolve();
        if (!container.dockerfile || !container.dockerfile.name)
            throw new Error("Container has nor image nor custom Dockerfile");
        const dir = `${this.output}/${container.name}`;
        await fs.promises.mkdir(`${dir}`, { recursive: true });
        (container.scripts || []).forEach(async (script) => await fs.promises.mkdir(path.dirname(`${dir}/${script.name}`), { recursive: true }));
        return Promise.all([
            fs.promises.writeFile(`${dir}/${container.dockerfile.name}`, container.dockerfile.body),
            ...(container.scripts || []).map((script) => fs.promises.writeFile(`${dir}/${script.name}`, script.body).then(() => fs.promises.chmod(`${dir}/${script.name}`, "755"))),
        ]);
    }
}
exports.EnvGenerator = EnvGenerator;


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Environment = void 0;
const container_1 = __webpack_require__(16);
class Environment {
    constructor(data) {
        this.name = data.name;
        if (data.containers) {
            this.containers = data.containers.map((c) => new container_1.Container(c));
        }
    }
}
exports.Environment = Environment;


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Container = void 0;
const script_1 = __webpack_require__(8);
class Container {
    constructor(data) {
        this.name = data.name;
        this.image = data.image;
        this.cmd = data.cmd;
        this.dockerfile = data.dockerfile ? new script_1.Script(data.dockerfile) : null;
        this.volumes = data.volumes;
        if (data.scripts) {
            this.scripts = data.scripts.map((s) => new script_1.Script(s));
        }
    }
}
exports.Container = Container;


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.dockerCompose = void 0;
const path = __webpack_require__(4);
class dockerCompose {
    prepare(env, output) {
        return `\
version: '3'
services:
${env.containers.map(this.prepareContainer(output))}`;
    }
    prepareContainer(output) {
        return (container) => {
            return `  ${container.name}:\n` +
                (container.image
                    ?
                        `    image: ${container.image}\n`
                    :
                        `    build:
      context: ./${path.relative(output, `${output}/${container.name}`)}
      dockerfile: ${container.dockerfile.name}`) +
                `\n    tty: true
    volumes:\n` +
                Object.entries(container.volumes).map(([src, dst]) => `      - ${src}:${dst}`).join("\n")
                + `${container.cmd ?
                    `\n    command: ${container.cmd}` : ""}`
                + (container.links
                    ?
                        `\n    links:\n
      -${container.links.join("\n      -")}`
                    : "")
                + "\n";
        };
    }
}
exports.dockerCompose = dockerCompose;


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.SourcePool = void 0;
const entity_1 = __webpack_require__(2);
const utils_1 = __webpack_require__(5);
var LoadableType;
(function (LoadableType) {
    LoadableType["ENTITY"] = "entity";
    LoadableType["IMPLEMENTATION"] = "ID";
    LoadableType["RESOURCE"] = "RES";
})(LoadableType || (LoadableType = {}));
class SourcePool {
    constructor(sources) {
        this.sources = sources;
    }
    async loadInstance(entity, data) {
        const instName = typeof entity === "string" ? entity : entity.name;
        const instanceEntity = utils_1.Utils.merge(await this.load(LoadableType.ENTITY, instName), typeof entity === "string" ? {} : entity);
        return (data.ID
            ? this.load(LoadableType.IMPLEMENTATION, instName, data.ID)
            : Promise.resolve(data))
            .then(async (reqImp) => ({
            ...(await this.loadObject(reqImp, instanceEntity)),
            ...data,
        }));
    }
    loadEntity(entName) {
        return this.load(LoadableType.ENTITY, entName);
    }
    load(type, p0x0Name, ID = null, sources = null) {
        if (type === LoadableType.ENTITY && entity_1.CARDINALS.includes(p0x0Name)) {
            return Promise.resolve(p0x0Name);
        }
        const _srcStack = (sources || this.sources).slice(0);
        return new Promise((resolve, reject) => {
            const search = () => {
                if (!_srcStack.length) {
                    return Promise.reject(`${p0x0Name} not found in sources: ${(sources || this.sources).map((s) => s.type).join()}`);
                }
                const srcT = _srcStack.pop();
                const typeMap = {};
                typeMap[LoadableType.ENTITY] =
                    () => srcT.load(p0x0Name, false)
                        .then((data) => new entity_1.Entity(data));
                typeMap[LoadableType.IMPLEMENTATION] = () => srcT.loadImplementation(p0x0Name, ID);
                typeMap[LoadableType.RESOURCE] = () => srcT.loadResource(p0x0Name);
                return typeMap[type]()
                    .catch((err) => _srcStack.length
                    ? search()
                    : Promise.reject(err));
            };
            return search()
                .then(resolve)
                .catch((err) => reject(err));
        });
    }
    async loadObject(obj, entity) {
        for (const prop in obj) {
            if (typeof obj[prop] === "object") {
                if (!entity.fields[prop]) {
                    throw new Error(`Unknown property "${prop}" in ${entity.name}`);
                }
                const { type, arraySize: isArray, mapKey: isMap, functionArguments: isFunction } = entity_1.Entity.getTypeFromString(entity.fields[prop]);
                const propEnt = await this.loadEntity(type);
                const getPropValFnc = async (val) => {
                    if (val.RES) {
                        return await this.load(LoadableType.RESOURCE, val.RES);
                    }
                    if (val.ID) {
                        val = await this.load(LoadableType.IMPLEMENTATION, propEnt.name, val.ID)
                            .then((imp) => ({ ...imp, ...val }));
                    }
                    return await this.loadObject(val, propEnt);
                };
                if (isMap) {
                    for (const key in obj[prop]) {
                        if (obj[prop].hasOwnProperty(key)) {
                            obj[prop][key] = await getPropValFnc(obj[prop][key]);
                        }
                    }
                }
                else if (isArray) {
                    obj[prop] = await Promise.all(obj[prop].map((v) => getPropValFnc(v)));
                }
                else {
                    obj[prop] = obj[prop] && await getPropValFnc(obj[prop]);
                }
            }
        }
        return obj;
    }
}
exports.SourcePool = SourcePool;


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.sourceFactory = exports.formatTypes = void 0;
const formats_1 = __webpack_require__(20);
const file_source_1 = __webpack_require__(24);
const remote_source_1 = __webpack_require__(25);
const _formatTypes = {};
for (const srct of formats_1.formats) {
    _formatTypes[(new srct()).type] = srct;
}
exports.formatTypes = _formatTypes;
function sourceFactory(conf) {
    let source = file_source_1.p0x0fileSource;
    const cnf = typeof conf === "string"
        ? { type: conf }
        : conf;
    if (cnf.url) {
        source = remote_source_1.p0x0remoteSource;
    }
    return new source(cnf, new exports.formatTypes[cnf.type](cnf));
}
exports.sourceFactory = sourceFactory;


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.formats = void 0;
const json_1 = __webpack_require__(21);
const p0x0_1 = __webpack_require__(23);
exports.formats = [json_1.json, p0x0_1.p0x0];


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.json = void 0;
const convertor_1 = __webpack_require__(9);
class json extends convertor_1.p0x0convertor {
    convert(buff) {
        return Promise.resolve(JSON.parse(buff.toString()));
    }
}
exports.json = json;


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.p0x0 = void 0;
class p0x0 {
}
exports.p0x0 = p0x0;


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.p0x0 = void 0;
const convertor_1 = __webpack_require__(9);
class p0x0 extends convertor_1.p0x0convertor {
    convert(buff) {
        return Promise.resolve(JSON.parse(buff.toString()));
    }
}
exports.p0x0 = p0x0;


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.p0x0fileSource = void 0;
const fs = __webpack_require__(1);
const source_1 = __webpack_require__(10);
class p0x0fileSource extends source_1.p0x0source {
    constructor(config = null, convertor = null) {
        super(config, convertor);
        this.config = config;
        this.convertor = convertor;
        this._dir = `${process.cwd()}/entities`;
        if (this.config && this.config.dir) {
            if (!this._dir.match(/^\//)) {
                const relPath = this._dir.match(/^\.\//)
                    ? this.config.dir.slice(2)
                    : this.config.dir;
                this._dir = `${process.cwd()}/${relPath}`;
            }
            else {
                this._dir = this.config.dir;
            }
        }
    }
    get type() { return this.convertor.type; }
    get dir() { return this._dir; }
    get ext() {
        return this.convertor.type;
    }
    loadImplementation(name, ID) {
        const p0x0FileName = `${ID}.${this.ext}`;
        return this.readFile(p0x0FileName)
            .then((buff) => this.convertor.convert(buff));
    }
    loadResource(RESID) {
        return this.readFile(RESID);
    }
    load(name, raw = false) {
        const p0x0FileName = `${name}.${this.ext}`;
        return this.readFile(p0x0FileName)
            .then(async (buff) => raw
            ? buff.toString()
            : await this.convertor.convert(buff));
    }
    readFile(p0x0FileName) {
        return new Promise((resolve, reject) => fs.readFile(this._dir + "/" + p0x0FileName, (err, res) => {
            if (err)
                return reject(err);
            resolve(res);
        }));
    }
}
exports.p0x0fileSource = p0x0fileSource;


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.p0x0remoteSource = void 0;
const http = __webpack_require__(26);
const source_1 = __webpack_require__(10);
class p0x0remoteSource extends source_1.p0x0source {
    constructor(config, convertor = null) {
        super(config, convertor);
        this.config = config;
        this.convertor = convertor;
    }
    get type() { return this.convertor.type; }
    get dir() { return this._dir; }
    get ext() {
        return this.convertor.type;
    }
    loadImplementation(name, ID) {
        return this.getRemote(`${this.config.url}/${name}/${ID}`)
            .then((buff) => this.convertor.convert(buff));
    }
    loadResource(RES) {
        return this.getRemote(`${this.config.url}/${RES}`);
    }
    load(name, raw = false) {
        return this.getRemote(`${this.config.url}/${name}`)
            .then(async (buff) => raw
            ? buff.toString()
            : await this.convertor.convert(buff));
    }
    getRemote(url) {
        return new Promise((resolve, reject) => http.get(url, (res) => {
            if (res.statusCode < 200 || res.statusCode >= 400)
                reject(res.statusCode);
            let body = "";
            res.on("data", (data) => body += data);
            res.on("end", () => resolve(Buffer.from(body)));
        }));
    }
}
exports.p0x0remoteSource = p0x0remoteSource;


/***/ }),
/* 26 */
/***/ (function(module, exports) {

module.exports = require("http");

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.p0x0genConfig = void 0;
const model_1 = __webpack_require__(3);
class p0x0genConfig extends model_1.Model {
    constructor(config) {
        super({
            generators: ["ts"],
            output: "generator/",
            sources: [{ type: "json" }],
            ...config,
        });
    }
    validate() {
        const rules = [
            () => this.output.search(/\.\.\//) === -1,
        ];
        for (const r of rules) {
            if (!r()) {
                return false;
            }
        }
        return true;
    }
}
exports.p0x0genConfig = p0x0genConfig;


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var generator_1 = __webpack_require__(0);
Object.defineProperty(exports, "p0x0generator", { enumerable: true, get: function () { return generator_1.p0x0generator; } });
var ts_1 = __webpack_require__(29);
Object.defineProperty(exports, "ts", { enumerable: true, get: function () { return ts_1.ts; } });
var js_1 = __webpack_require__(30);
Object.defineProperty(exports, "js", { enumerable: true, get: function () { return js_1.js; } });
var java_1 = __webpack_require__(31);
Object.defineProperty(exports, "java", { enumerable: true, get: function () { return java_1.java; } });
var sqlite_1 = __webpack_require__(32);
Object.defineProperty(exports, "sqlite", { enumerable: true, get: function () { return sqlite_1.sqlite; } });


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ts = void 0;
const entity_1 = __webpack_require__(2);
const generator_1 = __webpack_require__(0);
class ts extends generator_1.p0x0generator {
    static mapCardinals(cardinal) {
        if (!entity_1.CARDINALS.includes(cardinal))
            return null;
        switch (cardinal) {
            case "None": return "void";
            case "Float":
            case "Int": return "number";
            case "Bool": return "boolean";
            default:
                return cardinal.toLowerCase();
        }
    }
    async prepare(obj) {
        const imports = obj.dependencies || {};
        const allowedTypes = [...entity_1.CARDINALS.map(ts.mapCardinals), obj.name];
        const base = obj.base || null, extend = base ? `extends ${base} ` : "";
        const fields = obj.fields, fieldsNames = Object.getOwnPropertyNames(fields);
        const importedEntities = [
            ...Object.entries(imports).reduce((a, [, entities]) => [...a, ...entities], []),
        ];
        let externalEntities = [];
        if (base) {
            if (!importedEntities.includes(base)) {
                externalEntities.push(base);
            }
            allowedTypes.push(base);
        }
        externalEntities.concat(...Object.entries(fields)
            .map(([, fld]) => {
            const value = typeof fld === "string" ? fld : fld.type;
            return entity_1.Entity.getTypeFromString(value).type;
        })
            .filter((type) => ![...importedEntities, ...entity_1.CARDINALS].includes(type)));
        externalEntities = [...(new Set(externalEntities))];
        if (externalEntities.length) {
            // TODO ~ search entities paths
            externalEntities.forEach((ent) => imports[`./${ent}`] = [...(imports[`./${ent}`] || []), ent]);
        }
        let res = `${Object.entries(imports).map(([path, entities]) => {
            allowedTypes.concat(...entities);
            return `import {${entities.join(", ")}} from "${path}";`;
        }).join("\n")}
export class ${obj.name} ${extend ? `${extend} ` : ""}${obj.contracts ? ` implements ${obj.contracts.join(", ")} ` : ""}{
`;
        for (const p of fieldsNames) {
            const v = fields[p] && fields[p].default
                ? JSON.stringify(fields[p].default)
                : "";
            // tslint:disable-next-line:prefer-const
            let { type, arraySize: isArray, mapKey, functionArguments: funcArgs, isPrivate, isProtected, isStatic, default: dfault } = entity_1.Entity.getTypeFromString(fields[p].type || obj.fields[p]);
            if (entity_1.CARDINALS.includes(type)) {
                type = ts.mapCardinals(type);
            }
            if (!type || !allowedTypes.includes(type)) {
                type = "any";
            }
            if (mapKey) {
                if (!allowedTypes.includes(mapKey))
                    mapKey = "string";
                type = `Map<${mapKey}, ${type}>`;
            }
            else if (isArray) {
                type = `${type}[]`;
            }
            else if (funcArgs) {
                if (dfault) {
                    const fnc = await this.sources.loadInstance("p0x0Function", { ID: dfault });
                    const args = Object.entries(fnc.arguments)
                        .map(([name, varType]) => `${varType} ${name}`).join(", ");
                    const body = fnc.body.split("\n").map((row) => `        ${row}`).join("\n");
                    return `${isPrivate ? "private" : (isProtected ? "protected" : "public")} `
                        + `${isStatic ? "static " : ""} ${p}(${args}): ${type} {\n${body}\n    }`;
                }
                else {
                    const args = funcArgs.map((arg, i) => `${arg} arg${i}`).join(", ");
                    return `    ${isPrivate ? "private" : (isProtected ? "protected" : "public")} `
                        + `${isStatic ? "static " : ""} ${p}(${args}):${type} {\n    // TODO: implement\n}`;
                }
            }
            res += `    public ${p}: ${type}${v && ` = ${v}`};\n`;
        }
        res += `}\n`;
        return res;
    }
}
exports.ts = ts;


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.js = void 0;
const entity_1 = __webpack_require__(2);
const generator_1 = __webpack_require__(0);
// copy-paste from TS output
class js extends generator_1.p0x0generator {
    async prepare(obj) {
        const { base, name } = obj;
        return `"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
exports.${name} = void 0;
${base ? `var imports_1 = require("./imports");` : ""}
var ${name} = /** @class */ (function (_super) {
    __extends(${name}, _super);
    function ${name}() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return ${name};
}(${base ? `imports_1.Model` : "{}"}));
exports.${name} = ${name};`;
    }
    async prepareMethods(obj) {
        return (await Promise.all(Object.entries(obj.fields)
            .map(async ([name, value]) => {
            const { functionArguments: funcArgs, default: dfault } = entity_1.Entity.getTypeFromString(value);
            if (!funcArgs)
                return "";
            return dfault
                ? this.loadFncValue(dfault)
                : `    this.${name} = () => {\n        //  TODO\n    }`;
        }))).join("\n");
    }
    async loadFncValue(dfault) {
        const fnc = await this.sources.loadInstance("p0x0Function", { ID: dfault });
        const args = Object.entries(fnc.arguments)
            .map(([name, varType]) => `${varType} ${name}`).join(", ");
        const body = fnc.body.split("\n").map((row) => `        ${row}`).join("\n");
        return `    ${fnc.name}(${args}) {\n${body}\n    }`;
    }
}
exports.js = js;


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.java = exports.CARDINALS = void 0;
const entity_1 = __webpack_require__(2);
const generator_1 = __webpack_require__(0);
exports.CARDINALS = [...entity_1.CARDINALS, ...entity_1.CARDINALS.map((type) => `Volatile${type}`)];
class java extends generator_1.p0x0generator {
    static mapCardinals(cardinal) {
        if (!exports.CARDINALS.includes(cardinal))
            return null;
        const volatile = cardinal.match(/^Volatile[A-Z]/);
        if (volatile)
            cardinal = cardinal.substr(8);
        let type;
        switch (cardinal) {
            case "None":
                type = "void";
                break;
            case "String":
                type = cardinal;
                break;
            case "Bool":
                type = "boolean";
                break;
            default:
                type = cardinal.toLowerCase();
        }
        return `${volatile ? "volatile " : ""}${type}`;
    }
    async prepare(obj) {
        const imports = obj.dependencies || {};
        let allowedTypes = [...exports.CARDINALS, obj.name];
        const base = obj.base || null;
        const fields = obj.fields;
        const importedEntities = [
            ...Object.entries(imports).reduce((a, [, entities]) => [...a, ...entities], []),
        ];
        allowedTypes = [...allowedTypes, ...importedEntities];
        let externalEntities = [];
        if (base) {
            if (!importedEntities.includes(base)) {
                externalEntities.push(base);
            }
            allowedTypes.push(base);
        }
        externalEntities.concat(...Object.entries(fields)
            .map(([nm, fld]) => {
            const value = typeof fld === "string" ? fld : fld.type;
            try {
                return entity_1.Entity.getTypeFromString(value).type;
            }
            catch (e) {
                throw new Error(`Decif failed for entity property ${obj.name}:${nm} ~  ${value}\n`);
            }
        })
            .filter((type) => ![...importedEntities, ...exports.CARDINALS].includes(type)));
        externalEntities = [...(new Set(externalEntities))];
        if (externalEntities.length) {
            /**
             *  TODO ~ search entities paths
             *  for now treat as if all encountered entities that are not listed in dependencies
             *  are from the same package
             *
            externalEntities.forEach((ent) =>
                imports[`./${ent}`] = [...(imports[`./${ent}`] || []), ent],
            );
            */
        }
        const fieldsAndMethods = await this.prepareFieldsAndMethods(obj, allowedTypes);
        return `package ${obj.package.replace(/^[.a-z\/]*\/?java\//, "").replace(/\//g, ".")};

${Object.entries(imports).reduce((a, [src, items]) => [...a, ...items.map((item) => `import ${src}.${item};`)], []).join("\n")}

public class ${obj.name}${obj.base ? ` extends ${obj.base}` : ""}${obj.contracts ? ` implements ${obj.contracts.join(", ")}` : ""} {
${fieldsAndMethods}
}`;
    }
    async prepareFieldsAndMethods(obj, allowedTypes) {
        return (await Promise.all(Object.entries(obj.fields).map(async ([p, filedValue]) => this.formatVariableType(filedValue, allowedTypes, p === obj.name)
            .then((formatter) => formatter(p))
            .catch((e) => {
            throw new Error(`${e.message} in entity "${obj.name}"`);
        })))).join("\n");
    }
    convertType(p0x0Type) {
        let { type, arraySize, mapKey, nullable, functionArguments } = entity_1.Entity.getTypeFromString(p0x0Type);
        if (exports.CARDINALS.includes(type)) {
            type = java.mapCardinals(type);
        }
        if (mapKey) {
            if (!exports.CARDINALS.includes(mapKey)) {
                throw Error(`"${mapKey}" can't be used as a Map key`);
            }
            type = `Map<${this.convertType(mapKey)}, ${this.convertType(type)}>`;
        }
        else if (arraySize) {
            type = `${this.convertType(type)}[]`;
        }
        return type;
    }
    async formatFunction(isConstructor, type, funcArgs, isPrivate, isProtected, isStatic, dfault) {
        let prefix = `${isPrivate ? "private" : (isProtected ? "protected" : "public")} `
            + `${isStatic ? "static " : ""}${type}`;
        if (isConstructor) {
            prefix = `public`;
        }
        if (dfault) {
            const fnc = await this.sources.loadInstance("p0x0Function", { ID: dfault });
            const args = Object.entries(fnc.arguments || []).map(([name, varType]) => `${this.convertType(varType)} ${name}`).join(", ");
            const body = fnc.body.toString().split("\n").map((row) => `        ${row}`).join("\n");
            return (functionName) => `    ${fnc.parent ? "@Override\n    " : ""}`
                + `${prefix} ${functionName}(${args}) {\n${body}\n    }`;
        }
        else {
            const args = funcArgs.map((arg, i) => `${this.convertType(arg)} arg${i}`).join(", ");
            return (functionName) => `    ${prefix} ${functionName}(${args}) {\n        // TODO: implement\n    }`;
        }
    }
    async formatVariableType(varType, allowedTypes, isConstructor) {
        let { type, arraySize, mapKey, functionArguments: funcArgs, isPrivate, isProtected, isStatic, default: dfault } = entity_1.Entity.getTypeFromString(varType);
        if (!type || !allowedTypes.includes(type)) {
            throw new Error(`Unknown type "${type}"`);
        }
        type = this.convertType(varType);
        if (funcArgs) {
            return this.formatFunction(isConstructor, type, funcArgs, isPrivate, isProtected, isStatic, dfault);
        }
        if (arraySize && arraySize > 0 && !dfault) {
            dfault = `new ${type.replace(/\W/g, '')}[${arraySize}]`;
        }
        return (variableName) => `    ${isPrivate ? "private" : (isProtected ? "protected" : "public")} `
            + `${isStatic ? "static " : ""} ${type} ${variableName}${dfault ? ` = ${dfault}` : ""};`;
    }
}
exports.java = java;


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.sqlite = void 0;
const generator_1 = __webpack_require__(0);
class sqlite extends generator_1.p0x0generator {
    async prepare(obj) {
        let res = `CREATE TABLE "${obj.name}" (`;
        const names = Object.getOwnPropertyNames(obj.fields);
        const fields = obj.fields;
        const columns = [];
        /* TODO fix collecting fields from parent(base Entity)
         // tslint:disable-next-line:jsdoc-format
        for (let base = obj.base ; base && base.fields; base = base.base) {
            const baseFields = base.fields;
            names = names.concat(Object.getOwnPropertyNames(baseFields));
        }
        */
        for (const p of names) {
            const d = (fields[p] && fields[p].default) || "NULL", v = JSON.stringify(obj[p] || "") && ` DEFAULT ${d}`, t = (fields[p] && fields[p].default) && !isNaN(d) ? (d.toString().indexOf(".") !== -1 ? "INTEGER" : "REAL") : "TEXT";
            columns.push(`\t"${p}" ${t} ${v}`);
        }
        res += columns.join(",\n") + `);`;
        return res;
    }
}
exports.sqlite = sqlite;


/***/ })
/******/ ]);